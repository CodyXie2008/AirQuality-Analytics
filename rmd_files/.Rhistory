pca.fit=princomp(x, fix_sign=TRUE)
summary(pca.fit)
cbind(round(pca.fit$loadings[,1:4],2))
round(pca.fit$scores[,c(1:4)],2)
library(psych)
par(family='STKaiti')
fa.parallel(x,fa="fa",main="
碎
石
图")
fa.fit=fa(x,nfactors=4,rotate="varimax",fm="pa")
fa.fit
round(fa.fit$scores,2)
sample(1:712,50,replace = F)
runif()
runif(100)
```{r}
library(grid)
board_size <- 20
go_board <- matrix(0, nrow = board_size, ncol = board_size)
draw_board <- function() {
grid.newpage()
pushViewport(viewport(width = 0.9, height = 0.9))
for (i in 1:board_size) {
grid.lines(x = c(0.05, 0.95), y = c(i / board_size, i / board_size), gp = gpar(col = "black"))
grid.lines(x = c(i / board_size, i / board_size), y = c(0.05, 0.95), gp = gpar(col = "black"))
}
star_positions <- c(4, 10, 16)
for (i in star_positions) {
for (j in star_positions) {
grid.points(x = i / board_size, y = j / board_size, pch = 16, gp = gpar(col = "black", cex = 0.5))
}
}
}
draw_board_with_pieces <- function() {
draw_board()
for (i in 1:board_size) {
for (j in 1:board_size) {
if (go_board[i, j] == 1) {
grid.points(x = i / board_size, y = j / board_size, pch = 16, gp = gpar(col = "black", cex = 1.2))
} else if (go_board[i, j] == 2) {
grid.points(x = i / board_size, y = j / board_size, pch = 16, gp = gpar(col = "white", cex = 1.2, fill = "white"))
}
}
}
}
place_stone <- function(x, y, player) {
if (go_board[x, y] == 0) {
go_board[x, y] <<- player
draw_board_with_pieces()
} else {
message("该位置已有棋子，请选择其他位置。")
}
}
draw_board_with_pieces()
place_stone(10, 10, 1)
place_stone(11, 9, 2)
q()
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,dimnames = NULL)
# byrow 为 TRUE 元素按行排列
M <- matrix(c(3:14), nrow = 4, byrow = TRUE)
print(M)
# Ebyrow 为 FALSE 元素按列排列
N <- matrix(c(3:14), nrow = 4, byrow = FALSE)
print(N)
# 定义行和列的名称
rownames = c("row1", "row2", "row3", "row4")
colnames = c("col1", "col2", "col3")
P <- matrix(c(3:14), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))
print(P)
# 创建 2 行 3 列的矩阵
matrix1 <- matrix(c(7, 9, -1, 4, 2, 3), nrow = 2)
print(matrix1)
matrix2 <- matrix(c(6, 1, 0, 9, 3, 2), nrow = 2)
print(matrix2)
# 两个矩阵相乘
result <- matrix1 * matrix2
cat("相乘结果：","\n")
print(result)
# 两个矩阵相除
result <- matrix1 / matrix2
cat("相除结果：","\n")
print(result)
clear
---
title: "Project code"
dir()
# load in the dataset
project <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project)
# exploring, getting mean and median
summary(project)
# if we just want the dataset for one country
# filtering for Germany
germany_df <- project[(project$country_name == "Germany"),]
summary(germany_df)
# filtering for France
france_df <- project[(project$country_name == 'France'),]
summary(france_df)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$pm25_concentration)
# overall median PM10
median(project$pm10_concentration)
install.packages('dplyr')
library(dplyr)
project$pm25_concentration %>% log() %>% mean() %>% exp %>% round(1)
range(project$pm25_concentration)
max(project$pm25_concentration) - min(project$pm25_concentration)
quantile(project$pm25_concentration, probs = c(0.25, 0.75))
# compute the IQR
quantile(project$pm25_concentration, probs = 0.75) - quantile(project$pm25_concentration, probs = 0.25)
var(project$pm25_concentration)
sd(project$pm25_concentration)
install.packages('ggplot2')
library(ggplot2)
# bar chart for year; year is integer currently, we can change to categorical (factor)
ggplot(project, aes(x = factor(year))) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 350)
# histogram for PM2.5 across both countries
ggplot(project, aes(x = pm25_concentration)) + geom_histogram(bins = 25) + stat_bin(aes(label = after_stat(count)), bins = 25, vjust = -0.5, geom = 'text') + ylim(0, 300)
# dotplot for how PM10 is distributed across different years
# make sure you convert year to a factor
ggplot(project) + geom_dotplot(aes(x = factor(year), y = pm10_concentration), binaxis = 'y', stackdir = 'center', stackratio = 0)
# boxplot for how PM10 distribution varies between the two countries
ggplot(project) + geom_boxplot(aes(x = country_name, y = pm10_concentration))
# scatterplot
ggplot(project) + geom_point(aes(x = pm10_concentration, y = pm25_concentration), color = 'blue')
# also use country as a way to differentiate the points
ggplot(project) + geom_point(aes(x = pm10_concentration, y = pm25_concentration, color = country_name))
# two sample t test for our project
# let's say we hypothesise that AQ in Germany is worse than
# France. Is this true?
t.test(germany_df$pm25_concentration, france_df$pm25_concentration, alternative = 'greater')
# change the data source to germany_df or france_df for
# country-specific model
project_lm <- lm(pm25_concentration ~ pm10_concentration, project)
coef(project_lm)
pm25_prediction <- data.frame(pm10_concentration = c(40, 50, 60))
pm25_prediction
# using our model for predictions
pm25_prediction$prediction <- predict(project_lm, pm25_prediction)
pm25_prediction
# visualising our model
ggplot(project, aes(x = pm10_concentration, y = pm25_concentration)) + geom_point(color = 'blue') + geom_smooth(se = TRUE, method = lm, color = 'red')
# doing the hypothesis test for our model
summary(project_lm)
# compute residuals and fitted values
project$residuals <- residuals(project_lm)
project$fitted <- fitted(project_lm)
head(project)
# plot the normal probabiity plot
qqnorm(project$residuals)
qqline(project$residuals, col = 'steelblue', lwd = 2)
# e vs y^
plot(x = project$fitted, y = project$residuals)
# e vs x
plot(x = project$pm10_concentration, y = project$residuals)
# e vs time
plot(x = project$year, y = project$residuals)
# adding NO2 concentration as an additional predictor
project_mlr <- lm(pm25_concentration ~ pm10_concentration + no2_concentration, data = project)
coef(project_mlr)
# using our model for predictions
mlr_predictions <- data.frame(pm10_concentration = c(40, 50, 60),
no2_concentration = c(60, 40, 30))
mlr_predictions$predictions <- predict(project_mlr, mlr_predictions)
mlr_predictions
# doing the hypothesis test
summary(project_mlr)
# checking for multicollinearity
install.packages('car')
library(car)
vif(project_mlr)
dir()
join_df_full <- read.csv("join_df_full.csv")
summary(join_df_full)
head(join_df_full)
install.packages('ggplot2')
library(ggplot2)
# ggplot(data) + geom_object(aes(data to plot); parameters) + options
ggplot(join_df_full, aes(x = Region)) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 25)
ggplot(join_df_full, aes(x = SO2)) + geom_histogram(bins = 10) + stat_bin(aes(label = after_stat(count)), bins = 10, vjust = -0.5, geom = 'text') + ylim(0, 30)
ggplot(join_df_full) + geom_dotplot(aes(x = Region, y = PM10), binaxis = 'y', stackdir = 'center', stackratio = 1)
ggplot(join_df_full) + geom_boxplot(aes(x = Region, y = PM10))
ggplot(join_df_full) + geom_point(aes(x = PM10, y = PSI), color = 'blue')
dir()
join_df_full <- read.csv("join_df_full.csv")
summary(join_df_full)
head(join_df_full)
install.packages('ggplot2')
library(ggplot2)
# ggplot(data) + geom_object(aes(data to plot); parameters) + options
ggplot(join_df_full, aes(x = Region)) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 25)
ggplot(join_df_full, aes(x = SO2)) + geom_histogram(bins = 10) + stat_bin(aes(label = after_stat(count)), bins = 10, vjust = -0.5, geom = 'text') + ylim(0, 30)
ggplot(join_df_full) + geom_dotplot(aes(x = Region, y = PM10), binaxis = 'y', stackdir = 'center', stackratio = 1)
ggplot(join_df_full) + geom_boxplot(aes(x = Region, y = PM10))
ggplot(join_df_full) + geom_point(aes(x = PM10, y = PSI), color = 'blue')
dir()
join_df_full <- read.csv("join_df_full.csv")
head(join_df_full)
summary(join_df_full)
mean(join_df_full$SO2)
median(join_df_full$SO2)
(prod(join_df_full$SO2)) ** (1 / length(join_df_full$SO2))
# the above won't work for large datasets, with many rows
# the following is an alternative
install.packages('dplyr')
library(dplyr)
join_df_full$SO2 %>% log() %>% mean() %>% exp() %>% round(1)
install.packages('modeest')
# exploring, getting mean and median
summary(project)
dir()
# load in the dataset
project1 <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project)
# exploring, getting mean and median
summary(project)
# if we just want the dataset for one country
# filtering for Germany
germany_df <- project[(project$country_name == "Germany"),]
summary(germany_df)
# filtering for France
france_df <- project[(project$country_name == 'France'),]
summary(france_df)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$pm25_concentration)
# overall median PM10
median(project$pm10_concentration)
install.packages('dplyr')
library(dplyr)
project$pm25_concentration %>% log() %>% mean() %>% exp %>% round(1)
range(project$pm25_concentration)
max(project$pm25_concentration) - min(project$pm25_concentration)
quantile(project$pm25_concentration, probs = c(0.25, 0.75))
# compute the IQR
quantile(project$pm25_concentration, probs = 0.75) - quantile(project$pm25_concentration, probs = 0.25)
var(project$pm25_concentration)
sd(project$pm25_concentration)
install.packages('ggplot2')
library(ggplot2)
# bar chart for year; year is integer currently, we can change to categorical (factor)
ggplot(project, aes(x = factor(year))) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 350)
# histogram for PM2.5 across both countries
ggplot(project, aes(x = pm25_concentration)) + geom_histogram(bins = 25) + stat_bin(aes(label = after_stat(count)), bins = 25, vjust = -0.5, geom = 'text') + ylim(0, 300)
# dotplot for how PM10 is distributed across different years
# make sure you convert year to a factor
ggplot(project) + geom_dotplot(aes(x = factor(year), y = pm10_concentration), binaxis = 'y', stackdir = 'center', stackratio = 0)
# boxplot for how PM10 distribution varies between the two countries
ggplot(project) + geom_boxplot(aes(x = country_name, y = pm10_concentration))
# scatterplot
ggplot(project) + geom_point(aes(x = pm10_concentration, y = pm25_concentration), color = 'blue')
# also use country as a way to differentiate the points
ggplot(project) + geom_point(aes(x = pm10_concentration, y = pm25_concentration, color = country_name))
# two sample t test for our project
# let's say we hypothesise that AQ in Germany is worse than
# France. Is this true?
t.test(germany_df$pm25_concentration, france_df$pm25_concentration, alternative = 'greater')
# change the data source to germany_df or france_df for
# country-specific model
project_lm <- lm(pm25_concentration ~ pm10_concentration, project)
coef(project_lm)
pm25_prediction <- data.frame(pm10_concentration = c(40, 50, 60))
pm25_prediction
# using our model for predictions
pm25_prediction$prediction <- predict(project_lm, pm25_prediction)
pm25_prediction
# visualising our model
ggplot(project, aes(x = pm10_concentration, y = pm25_concentration)) + geom_point(color = 'blue') + geom_smooth(se = TRUE, method = lm, color = 'red')
# doing the hypothesis test for our model
summary(project_lm)
# compute residuals and fitted values
project$residuals <- residuals(project_lm)
project$fitted <- fitted(project_lm)
head(project)
# plot the normal probabiity plot
qqnorm(project$residuals)
qqline(project$residuals, col = 'steelblue', lwd = 2)
# e vs y^
plot(x = project$fitted, y = project$residuals)
# e vs x
plot(x = project$pm10_concentration, y = project$residuals)
# e vs time
plot(x = project$year, y = project$residuals)
# adding NO2 concentration as an additional predictor
project_mlr <- lm(pm25_concentration ~ pm10_concentration + no2_concentration, data = project)
coef(project_mlr)
# using our model for predictions
mlr_predictions <- data.frame(pm10_concentration = c(40, 50, 60),
no2_concentration = c(60, 40, 30))
mlr_predictions$predictions <- predict(project_mlr, mlr_predictions)
mlr_predictions
# doing the hypothesis test
summary(project_mlr)
# checking for multicollinearity
install.packages('car')
library(car)
vif(project_mlr)
dir()
# load in the dataset
project <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project)
# exploring, getting mean and median
summary(project)
# if we just want the dataset for one country
# filtering for Germany
germany_df <- project[(project$country_name == "Germany"),]
summary(germany_df)
# filtering for France
france_df <- project[(project$country_name == 'France'),]
summary(france_df)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$pm25_concentration)
# overall median PM10
median(project$pm10_concentration)
install.packages('dplyr')
library(dplyr)
project$pm25_concentration %>% log() %>% mean() %>% exp %>% round(1)
range(project$pm25_concentration)
max(project$pm25_concentration) - min(project$pm25_concentration)
quantile(project$pm25_concentration, probs = c(0.25, 0.75))
# compute the IQR
quantile(project$pm25_concentration, probs = 0.75) - quantile(project$pm25_concentration, probs = 0.25)
var(project$pm25_concentration)
sd(project$pm25_concentration)
install.packages('ggplot2')
library(ggplot2)
# bar chart for year; year is integer currently, we can change to categorical (factor)
ggplot(project, aes(x = factor(year))) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 350)
# histogram for PM2.5 across both countries
ggplot(project, aes(x = pm25_concentration)) + geom_histogram(bins = 25) + stat_bin(aes(label = after_stat(count)), bins = 25, vjust = -0.5, geom = 'text') + ylim(0, 300)
# dotplot for how PM10 is distributed across different years
# make sure you convert year to a factor
ggplot(project) + geom_dotplot(aes(x = factor(year), y = pm10_concentration), binaxis = 'y', stackdir = 'center', stackratio = 0)
# boxplot for how PM10 distribution varies between the two countries
ggplot(project) + geom_boxplot(aes(x = country_name, y = pm10_concentration))
# scatterplot
ggplot(project) + geom_point(aes(x = pm10_concentration, y = pm25_concentration), color = 'blue')
# also use country as a way to differentiate the points
ggplot(project) + geom_point(aes(x = pm10_concentration, y = pm25_concentration, color = country_name))
# two sample t test for our project
# let's say we hypothesise that AQ in Germany is worse than
# France. Is this true?
t.test(germany_df$pm25_concentration, france_df$pm25_concentration, alternative = 'greater')
# change the data source to germany_df or france_df for
# country-specific model
project_lm <- lm(pm25_concentration ~ pm10_concentration, project)
coef(project_lm)
pm25_prediction <- data.frame(pm10_concentration = c(40, 50, 60))
pm25_prediction
# using our model for predictions
pm25_prediction$prediction <- predict(project_lm, pm25_prediction)
pm25_prediction
# visualising our model
ggplot(project, aes(x = pm10_concentration, y = pm25_concentration)) + geom_point(color = 'blue') + geom_smooth(se = TRUE, method = lm, color = 'red')
# doing the hypothesis test for our model
summary(project_lm)
# compute residuals and fitted values
project$residuals <- residuals(project_lm)
project$fitted <- fitted(project_lm)
head(project)
# plot the normal probabiity plot
qqnorm(project$residuals)
qqline(project$residuals, col = 'steelblue', lwd = 2)
# e vs y^
plot(x = project$fitted, y = project$residuals)
# e vs x
plot(x = project$pm10_concentration, y = project$residuals)
# e vs time
plot(x = project$year, y = project$residuals)
# adding NO2 concentration as an additional predictor
project_mlr <- lm(pm25_concentration ~ pm10_concentration + no2_concentration, data = project)
coef(project_mlr)
# using our model for predictions
mlr_predictions <- data.frame(pm10_concentration = c(40, 50, 60),
no2_concentration = c(60, 40, 30))
mlr_predictions$predictions <- predict(project_mlr, mlr_predictions)
mlr_predictions
# doing the hypothesis test
summary(project_mlr)
# checking for multicollinearity
install.packages('car')
library(car)
vif(project_mlr)
install.packages("dplyr")
install.packages("car")
install.packages("ggplot2")
dir()
# load in the dataset
project <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project)
# load in the dataset
project1 <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project)
# exploring, getting mean and median
summary(project)
# load in the dataset
project <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project1)
# load in the dataset
project <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project1)
# exploring, getting mean and median
summary(project)
# load in the dataset
project <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project)
# exploring, getting mean and median
summary(project)
# if we just want the dataset for one country
# filtering for Germany
germany_df <- project[(project$country_name == "Germany"),]
summary(germany_df)
# load in the dataset
project <- read.csv("WHO_DB_FR_GER_cleaned_2024.csv")
head(project)
# exploring, getting mean and median
summary(project)
# if we just want the dataset for one country
# filtering for Germany
germany_df <- project[(project$country_name == "Germany"),]
summary(germany_df)
# filtering for France
france_df <- project[(project$country_name == 'France'),]
summary(france_df)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$pm25_concentration)
# filtering for France
france_df <- project[(project$country_name == 'France'),]
summary(france_df)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$pm25_concentration)
# exploring, getting mean and median
summary(project)
# overall median PM10
median(project$pm10_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
france_df <- project[(project$country_name == 'France'),]
mean(project$pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
france_df <- project[(project$country_name == 'France'),]
mean(project$pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(projec$pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$country_name == 'France',pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$country_name == 'France'pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(project$country_name == 'France'$pm25_concentration)
# overall mean for entire dataset for PM2.5; substitute with germany_df
# or france_df for country-specific mean
mean(france_df$pm25_concentration)
# filtering for France
france_df <- project[(project$country_name == 'France'),]
summary(france_df)
# overall median PM10
median(project$pm10_concentration)
# or france_df for country-specific mean
mean(france_df$pm25_concentration)
# filtering for France
france_df <- project[(project$country_name == 'France'),]
summary(france_df)
# or france_df for country-specific mean
Min(france_df$pm25_concentration)
# or france_df for country-specific mean
min(france_df$pm25_concentration)
install.packages('dplyr')
install.packages('dplyr')
library(dplyr)
project$pm25_concentration %>% log() %>% mean() %>% exp %>% round(1)
install.packages('dplyr')
library(dplyr)
project$pm25_concentration %>% log() %>% mean() %>% exp %>% round(1)
range(project$pm25_concentration)
max(project$pm25_concentration) - min(project$pm25_concentration)
quantile(project$pm25_concentration, probs = c(0.25, 0.75))
# compute the IQR
quantile(project$pm25_concentration, probs = 0.75) - quantile(project$pm25_concentration, probs = 0.25)
var(project$pm25_concentration)
sd(project$pm25_concentration)
# bar chart for year; year is integer currently, we can change to categorical (factor)
ggplot(project, aes(x = factor(year))) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 350)
install.packages('ggplot2')
library(ggplot2)
# bar chart for year; year is integer currently, we can change to categorical (factor)
ggplot(project, aes(x = factor(year))) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 350)
# histogram for PM2.5 across both countries
ggplot(project, aes(x = pm25_concentration)) + geom_histogram(bins = 25) + stat_bin(aes(label = after_stat(count)), bins = 25, vjust = -0.5, geom = 'text') + ylim(0, 300)
# bar chart for year; year is integer currently, we can change to categorical (factor)
ggplot(project, aes(x = factor(year))) + geom_bar(stat = 'count', width = 1.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 350)
# bar chart for year; year is integer currently, we can change to categorical (factor)
ggplot(project, aes(x = factor(year))) + geom_bar(stat = 'count', width = 0.5) + stat_count(aes(label = after_stat(count)), vjust = -0.5, geom = 'text') + ylim(0, 350)
# dotplot for how PM10 is distributed across different years
# make sure you convert year to a factor
ggplot(project) + geom_dotplot(aes(x = factor(year), y = pm10_concentration), binaxis = 'y', stackdir = 'center', stackratio = 0)
